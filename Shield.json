{"slots":{"0":{"name":"shieldGenerator","type":{"methods":[],"events":[]},"_elementType":"shieldGenerator"},"1":{"name":"slot2","type":{"methods":[],"events":[]}},"2":{"name":"slot3","type":{"methods":[],"events":[]}},"3":{"name":"slot4","type":{"methods":[],"events":[]}},"4":{"name":"slot5","type":{"methods":[],"events":[]}},"5":{"name":"slot6","type":{"methods":[],"events":[]}},"6":{"name":"slot7","type":{"methods":[],"events":[]}},"7":{"name":"slot8","type":{"methods":[],"events":[]}},"8":{"name":"slot9","type":{"methods":[],"events":[]}},"9":{"name":"slot10","type":{"methods":[],"events":[]}},"-1":{"name":"unit","type":{"methods":[],"events":[]},"_elementType":"control"},"-2":{"name":"system","type":{"methods":[],"events":[]},"_elementType":"system"},"-3":{"name":"library","type":{"methods":[],"events":[]},"_elementType":"library"},"-4":{"name":"player","type":{"methods":[],"events":[]},"_elementType":"player"},"-5":{"name":"construct","type":{"methods":[],"events":[]},"_elementType":"construct"}},"handlers":[{"key":"0","filter":{"slotKey":0,"signature":"onToggled(active)","args":[{"variable":"*"}]},"code":"if register ~= nil then register:callAction(\"OnToggled\",active,shieldGenerator) end"},{"key":"1","filter":{"slotKey":0,"signature":"onAbsorbed(hitpoints,rawHitpoints)","args":[{"variable":"*"},{"variable":"*"}]},"code":"if register ~= nil then register:callAction(\"OnAbsorbed\",hitpoints,rawHitpoints,shieldGenerator) end"},{"key":"2","filter":{"slotKey":0,"signature":"onVentin(active,restoredHitpoints)","args":[{"variable":"*"},{"variable":"*"}]},"code":"if register ~= nil then register:callAction(\"OnVentin\",active,restoredHitpoints,shieldGenerator) end"},{"key":"3","filter":{"slotKey":0,"signature":"onDown()","args":[]},"code":"if register ~= nil then register:callAction(\"OnDown\",shieldGenerator) end"},{"key":"4","filter":{"slotKey":0,"signature":"onRestored()","args":[]},"code":"if register ~= nil then register:callAction(\"OnRestored\",shieldGenerator) end"},{"key":"5","filter":{"slotKey":-1,"signature":"onStart()","args":[]},"code":"packagePrefix = \"autoconf.custom.AresOS.\"\npackage.preload[packagePrefix..\"shieldreconfigure\"] = function()\n   local self = {}\nself.version = 0.9\nlocal auth = \"AQN5B4-@7gSt1W?;\"\nfunction self:valid(key)\n    if key ~= auth then return false end\n    return shield ~= nil\nend\nfunction self:register(env)\n    _ENV = env\n\tif shield == nil then return end\n    shield.activate()\n    register:addAction(\"OnAbsorbed\", \"shieldreconfigure\", Shieldreconfigure) --TODO\nend\nlocal ress_old = {0,0,0,0}\nfunction getRes(stress, pool)\n    local res = {0.15,0.15,0.15,0.15}\n    if stress[1] >= stress[2] and \n        stress[1] >= stress[3] and \n        stress[1] > stress[4] then\n        res = {pool,0,0,0}\n    elseif stress[2] >= stress[1] and \n            stress[2] >= stress[3] and \n            stress[2] > stress[4] then\n        res = {0,pool,0,0}\n    elseif stress[3] >= stress[1] and \n            stress[3] >= stress[2] and \n            stress[3] > stress[4] then\n        res = {0,0,pool,0}\n    elseif stress[4] >= stress[1] and \n            stress[4] >= stress[2] and \n            stress[4] > stress[3] then\n        res = {0,0,0,pool}\n    else\n        print(\"Fehler! Im else...\")\n    end\n    return res\nend\n\nfunction Shieldreconfigure()\n    if shield.getResistancesCooldown() == 0 then\n    --print(\"Schilde rekonfigurieren!!!\")\n    local pool = shield.getResistancesPool()\n    local stress = shield.getStressRatioRaw()\n    local res = getRes(stress, pool)\n    if ress_old[1] == res[1] and \n        ress_old[2] == res[2] and \n        ress_old[3] == res[3] and \n        ress_old[4] == res[4] then\n        --print(\"Ress sind gleich!\")\n    else\n        if shield.setResistances(res[1],res[2],res[3],res[4]) == 1 then\n            print(\"Schilde rekonfiguriert!\")\n            ress_old[1] = res[1]\n            ress_old[2] = res[2]\n            ress_old[3] = res[3]\n            ress_old[4] = res[4]\n        else\n            print(\"Fehler: \"..shield.getStressRatioRaw()[1]..\", \"\n                                ..shield.getStressRatioRaw()[2]..\", \"\n                                ..shield.getStressRatioRaw()[3]..\", \"\n                                ..shield.getStressRatioRaw()[4])   \n        end\n    end\n    end\nend\nreturn self\n\nend\npackage.preload[packagePrefix..\"slots\"] = function()\n   -- Slots is controlling all connected elements\nlocal self = {}\nself.slots = nil\nlocal buildIn = {control=true,library=true,system=true,unit=true,player=true,construct=true} -- Could be list, but quicker access times and easier to use indexed\n\nfunction self:calcSlots()\n    self.slots={}\n    local target = unit or {}\n    for key, value in pairs(target) do\n        if buildIn[key] == nil then\n            if type(key) == \"string\" and type(value) == \"table\" and type(value.export) == \"table\" then\n                self.slots[key] = value\n            end\n        end\n    end\n    return self.slots\nend\nfunction self:getSlots()\n    if self.slots == nil then\n        self:calcSlots()\n    end\n    return self.slots\nend\n\nself.elementsIdList = nil\nfunction self:calcElementList()\n    if core == nil then return end\n    self.elementsIdList = core.getElementIdList()\nend\nfunction self:getElementList()\n    if self.elementsIdList == nil then\n        self:calcElementList()\n    end\n    return self.elementsIdList\nend\n\n-- First 5 letters of name\nlocal unitTypeClass = {\n\tRemoteControlUnit = \"remote\", CockpitHovercraftUnit = \"command\", PVPSeatUnit = \"gunner\" , CockpitCommandmentUnit = \"command\", CockpitFighterUnit = \"command\"\n}\nlocal slotSubClass = {\n\tWeapo = \"weapon\", Shiel = \"shield\", Radar = \"radar\" , CoreU = \"core\"\n}\nlocal slotClasses = {\n    AntiGravityGeneratorUnit=\"antigrav\",WarpDriveUnit=\"warpdrive\",DataBankUnit=\"databases\",\n    ReceiverUnit = \"receiver\",EmitterUnit=\"emitter\",ScreenUnit=\"screens\",CombatDefense=\"transponder\",\n    AtmoFuelContainer = \"atmofueltank\",SpaceFuelContainer = \"spacefueltank\",RocketFuelContainer = \"rocketfueltank\",CounterUnit=\"counter\",laserDetector=\"laser\",\n    SpaceEngine = \"engine\"\n}\nlocal slotLists = {\n    weapon=true,databases=true,screens=true,atmofueltank=true,spacefueltank=true,rocketfueltank=true,radar=true,engine=true\n}\nlocal eventRegister = {\n  core = {\"onStressChanged(stress)\"},\n  container = {\"onContentUpdate()\"},\n  industry = {\"onStarted(id,quantity)\", \"onCompleted(id,quantity)\", \"onStatusChanged(status)\",\"onBankUpdate()\"},\n  radar = {\"onEnter(id)\",\"onLeave(id)\",\"onIdentified(id)\"},\n  screens = {\"mouseDown(x,y)\", \"mouseUp(x,y)\", \"onOutputChanged(output)\"},\n  laser = { \"onHit()\", \"onLoss()\" },\n  receiver = {\"onReceived(channel,message)\"},\n  shield = {\"onToggled(active)\",\"onAbsorbed(hitpoints,rawHitpoints)\",\"onVentin(active,restoredHitpoints)\",\"onDown()\",\"onRestored()\"},\n  weapon = { \"onReload(ammoId)\", \"onReloaded(ammoId)\", \"onMissed(targetId)\", \"onDestroyed(targetId)\", \"onElementDestroyed(targetId,itemId)\", \"onHit(targetId,damage)\"},\n\n  -- abstract\n  --enterable =  { \"enter(id)\", \"leave(id)\"},\n  --pressable =  { \"pressed()\", \"released()\"},\n\n  -- built-in\n  --control = { \"onStop()\", \"onTimer(tag)\"},\n  --system = { \"onActionStart(action)\", \"onActionStop(action)\", \"onActionLoop(action)\", \"onUpdate()\", \"onFlush()\", \"onInputText(text)\"},\n  --player = { \"onParentChanged(oldId,newId)\"},\n  --construct = { \"onDocked(id)\", \"onUndocked(id)\", \"onPlayerBoarded(id)\", \"onVRStationEntered(id)\", \"onConstructDocked(id)\", \"onPvPTimer(active)\"}\n}\n\nlocal function getArgsForFilter (filterSignature)\n    for k,v in ipairs(filterSignature) do\n        local funName, funArgs = v:match(\"^([^(]+)%((.*)%)\")\n    \n        local argNames = {}\n        for argName in funArgs:gmatch(\"[^%s,]+\") do table.insert(argNames, argName) end\n        for _,g in ipairs(argNames) do\n            print(string.format(\"* Slot name %q has options %q.\", funName, g))\n        end\n        local mappedArgs = map(argNames, function () return \"*\" end)\n        for _,g in ipairs(mappedArgs) do\n            print(string.format(\"* Slot name %q has options %q.\", funName, g))\n        end\n\t\t\n\t\t\n    end\nend\nfunction self:getClassType(class)\n\tlocal type\n\tif slotClasses[class] ~= nil then\n\t\ttype = slotClasses[class]\n\telse\n\t\tlocal c = string.sub(class,0,5)\n\t\tif slotSubClass[c] ~= nil then\n\t\t\ttype = slotSubClass[c]\n\t\tend\n\tend\n\t--if type == nil then\n\t\t--system.print(\"Unrecognized Type: \"..class)\n\t--end\n\treturn type\nend\nfunction self:register(env)\n    _ENV = env\n\n    for type, _ in pairs(slotLists) do\n        _ENV[type] = {}\n    end\n    for _, slotElement in pairs(self:getSlots()) do\n        local class = slotElement.getClass()\n\t\tlocal type = self:getClassType(class)\n\t\t\n\t\tif type == nil then\n\t\t\tsystem.print(\"Unrecognized Type: \"..class)\n\t\telse\n\t\t\tif slotLists[type] == nil then\n                _ENV[type] = slotElement\n            else\n                table.insert(_ENV[type], slotElement)\n            end\n\t\tend\n    end\n\n    function compare(a, b)\n        if a ~= nil and a.getLocalId and b ~= nil and b.getLocalId then\n            return a.getLocalId() < b.getLocalId()\n        end\n        return nil\n    end\n    for type, _ in pairs(slotLists) do\n        if #_ENV[type] > 1 then table.sort(_ENV[type],compare) end\n    end\n\n    if #_ENV[\"databases\"] > 0 then\n        local bankraid = getPlugin(\"bankraid\",true)\n        if bankraid ~= nil then\n            _ENV[\"database\"] = bankraid:new(_ENV[\"databases\"])\n        else\n            _ENV[\"database\"] = _ENV[\"databases\"][1]\n        end\n    end\n\n\tif _ENV[\"unitType\"] == nil or _ENV[\"unitType\"] == \"\" then\n\t\tif unitTypeClass[unit.getClass()] ~= nil then\n\t\t\t_ENV[\"unitType\"] = unitTypeClass[unit.getClass()]\n\t\telse\n\t\t\t--print(\"Unrecognized unitTypeClass: \"..unit.getClass())\n\t\tend\n\tend\n\t\n    register:addAction(\"antigravityStart\", \"antigravityStart\", function()\n        if antigrav ~= nil then\n            antigrav.toggle()\n        end\n    end)\n\n    register:addAction(\"systemOnUpdate\", \"frameCounter\",\n            function()\n                if executeTotal == nil then executeTotal = 0 end\n                if executeSet == nil then executeSet = 0 end\n\n                executeTotal = executeTotal + 1\n                executeSet = executeSet + 1\n                local currTime = system.getArkTime()\n                if (currTime - executeTime) > 1 then\n                    executeLastFrames = executeSet\n                    executeSet = 1\n                    executeTime = currTime\n                    local showFrames = false --export: Will show current frames in console only\n                    if showFrames then\n                        system.print(\"Frames: \" .. executeLastFrames)\n                    end\n                end\n            end\n    )\n    register:addAction(\"systemOnActionStart\", \"systemActionStartAlias\",\n            function(action, system)\n                register:callAction(action .. \"Start\", system)\n\t\t\t\tregister:startHotkeyPressed(action)\n            end\n    )\n    register:addAction(\"systemOnActionStop\", \"systemActionStopAlias\",\n            function(action, system)\n                register:callAction(action .. \"Stop\", system)\n\t\t\t\tregister:endHotkeyPressed(action)\n            end\n    )\n    register:addAction(\"systemOnActionLoop\", \"systemActionLoopAlias\",\n            function(action, system)\n                register:callAction(action .. \"Loop\", system)\n            end\n    )\nend\nreturn self\nend\npackage.preload[packagePrefix..\"register\"] = function()\n   -- Register is handling all event registrations\nlocal self = {}\nself.functionRegister = {}\nself.overwriteRegister = {}\nself.overwriteOrder = {}\nself.viewRegister = {} -- collection of all views\nself.pressedRegister = {} -- collection of all currently pressed keys. For performance reasons, only use this for events, not ship movement!\n\nfunction self:hotkeyState(hotkey)\n    if self.pressedRegister[hotkey] == 1 then\n        return 1\n    end\n    return 0\nend\nfunction self:startHotkeyPressed(hotkey)\n    self.pressedRegister[hotkey] = 1\nend\nfunction self:endHotkeyPressed(hotkey)\n    self.pressedRegister[hotkey] = nil\nend\n\n-- Switches are functions that can be activated or deactivated\n-- the property \"buttonName\" and functions like \"activate\", \"deactivate\" and \"isActive\" should be part of the entity passed\nself.switches = {}\nfunction self:addSwitch(name, entity)\n    assert(type(name) == \"string\", \"name isn't a string, type was \" .. type(name))\n    assert(type(entity) == \"table\", name .. \": entity isn't a table, type was \" .. type(entity))\n\n    self.switches[name] = entity\n\n    self:callAction(\"registerAddSwitch\", name)\nend\nfunction self:getSwitch(name)\n    assert(type(name) == \"string\", \"name isn't a string, type was \" .. type(name))\n    return self.switches[name]\nend\nfunction self:getSwitches()\n    return self.switches\nend\n\nself.taskRegister = { }\nself.taskOrder = {}\nlocal function compareTasks(a, b)\n    if a ~= nil and b ~= nil then\n        return self.taskRegister[a].order < self.taskRegister[b].order\n    end\n    return nil\nend\n--[[Adds a task that will be done one step (yield) every frame,\n    if there is not a task with lower or same priority number before that.\n    Tasks with a lot of yield and unset \"rating\" that run for a very long time may block important tasks.\n    \"rating\" is the amount of power, in relation the total cpu cycles, a task takes.\n    At the time of adding this rating, you could execute about 3500 commands before cpu overload.]]--\nlocal taskMaxRating = 2500\nfunction self:addTask(name, func, priority, rating)\n    assert(type(name) == \"string\", \"addTask: name isn't a string, type was \" .. type(name))\n    assert(type(func) == \"function\", name .. \": func isn't a function, type was \" .. type(func))\n    if priority == nil then\n        priority = 10\n    else\n        assert(type(priority) == \"number\" ,  name .. \": priority has to be number, type was \" .. type(priority))\n    end\n\n    if rating == nil then\n        rating = taskMaxRating\n    else\n        assert(type(rating) == \"number\" ,  name .. \": rating has to be number, type was \" .. type(rating))\n        assert(rating <= taskMaxRating ,  name .. \": rating has to be smaller then the allowed max rating of \" .. taskMaxRating)\n    end\n\n    if not self:hasAction(\"systemUpdate\",\"registerTasker\") then\n        self:addAction(\"systemUpdate\",\"registerTasker\",function() self:runTasks() end)\n    end\n\n    if self.taskRegister[name] ~= nil then self:removeTask(name) end\n\n    table.insert(self.taskOrder, name)\n    self.taskRegister[name] = {order=priority,task=coroutine.create(func),rating=rating}\n\n    if #self.taskOrder > 1 then table.sort(self.taskOrder,compareTasks) end\nend\nfunction self:hasTask(name)\n    return self.taskRegister[name] ~= nil\nend\nfunction self:removeTask(name)\n    assert(type(name) == \"string\", \"removeTask: Name isn't a string, type was \" .. type(name))\n\n    self.taskRegister[name] = nil\n    for k,v in pairs(self.taskOrder) do\n        if v == name then\n            table.remove(self.taskOrder,k)\n            return\n        end\n    end\nend\nfunction self:runTasks()\n    local currTasksRating = 0\n    for _, name in ipairs(self.taskOrder) do\n        local regTask = self.taskRegister[name]\n\n        if (currTasksRating + regTask.rating) <=  taskMaxRating then\n            if regTask.task == nil or coroutine.status(regTask.task) == \"dead\" then\n                self:removeTask(name)\n            else\n                currTasksRating = currTasksRating + regTask.rating\n                local ok, errorMsg = coroutine.resume(regTask.task)\n                if not ok then\n                    system.print(name ..\" in runTasks:\",errorMsg)\n                    self:removeTask(name)\n                end\n            end\n        end\n    end\nend\n\nfunction self:hasAction(action,name)\n    return self.functionRegister[action] ~= nil and self.functionRegister[action][name] ~= nil\nend\nfunction self:addAction(action, name, func)\n    assert(type(action) == \"string\", \"action isn't a string, type was \" .. type(action))\n    assert(type(name) == \"string\", action .. \": name isn't a string, type was \" .. type(name))\n    assert(type(func) == \"function\", action .. \":\" .. name .. \": func isn't a function, type was \" .. type(func))\n\n    if self.functionRegister[action] == nil then\n        self.functionRegister[action] = {}\n    end\n    self.functionRegister[action][name] = func\nend\nfunction self:removeAction(action, name)\n    if self.functionRegister[action] == nil or self.functionRegister[action][name] == nil then\n        return false\n    end\n    self.functionRegister[action][name] = nil\n    return true\nend\nfunction self:callAction(action, ...)\n    local results = {}\n    if self.functionRegister[action] ~= nil then\n        for name, func in pairs(self.functionRegister[action]) do\n            if func ~= nil then\n                local status, res = pcall(func, ...)\n                if status then\n                    results[name] = res\n                else\n                    system.print(name ..\" in callAction:\",res)\n                end\n            end\n        end\n    end\n    return results\nend\nfunction self:callActionSpecific(action, name, ...)\n\tassert(self.functionRegister[action] == \"table\", action .. \":\" .. \" not registered\")\n\tassert(self.functionRegister[action][name] == \"function\", action .. \":\" .. name .. \": called specified function isn't a function, type was \" .. type(self.functionRegister[action][name]))\n\t\n\tlocal status, res = pcall(self.functionRegister[action][name], ...)\n\tif status then\n\t\treturn res\n\telse\n\t\tsystem.print(name ..\" in callActionSpecific:\",res)\n\tend\nend\nreturn self\nend\nsystem.rawPrint = system.print\nfunction system.print(msg,err)\n    if err then\n        err = tostring(err):gsub('\"%-%- |STDERROR%-EVENTHANDLER[^\"]*\"', 'chunk'):gsub(\"&\", \"&amp;\"):gsub(\"<\", \"&lt;\"):gsub(\">\", \"&gt;\")\n    else\n        err = \"???\"\n    end\n    system.rawPrint(msg .. \" \".. err)\nend\nfunction print(str)\n    system.rawPrint(tostring(str))\nend\nlocal u = unit\nif devMode == true and player.hasDRMAutorization() ~= 1 then print(\"devMode set but no DRM auth\") error(\"devMode set but no DRM auth\") u.exit() end\nif u.hasDRM() == 0 then if devMode ~= true then print(\"DRM Required\") error(\"DRM Required\") u.exit() else print(\"DRM requirement skipped by devMode\") end end\nu.hideWidget()\nprint(\"Hyperion Gunner Script V0.97.2\")\nprint(\"by Hyperion Scripting\")\n\nsystem.showScreen(1) ---Start Screen\nsystem.setScreen([[<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"40%\" style=\"left:30%;top:10%;display:block; position:absolute;\" viewBox=\"0 0 973.35 837.57\">\n    <defs>\n    <style>\n    .cls-1 { fill: #798a99; }\n    .cls-2 { fill: #bd1730; }\n    </style>\n    </defs>\n    <path class=\"cls-1\" d=\"M583,93.5H437.52C353.65,361.21,211.41,603.08,25.7,804.26L98.3,930a1892.42,1892.42,0,0,1,828.89-.22l70.63-122.29C810.63,605.68,667.33,362.63,583,93.5ZM508.29,740.05A945,945,0,0,0,206.5,789.18C357.22,655.35,464.94,474.16,506.32,269c41.16,204.15,148,384.54,297.51,518.13A945.66,945.66,0,0,0,508.29,740.05Z\" transform=\"translate(-25.08 -93)\"/>\n    <circle class=\"cls-2\" cx=\"481.42\" cy=\"523.5\" r=\"118\"/>\n    </svg>\n    <svg height=\"100%\" width=\"100%\" viewBox=\"0 0 1920 1080\" style=\"left:0;top:0;display:block; position:absolute;\">\n    <text x=\"40%\" y=\"88%\" style=\"fill:#FFFFFF;font-size:50px\">Hyperion Scripting</text>\n    </svg>]])\n\nlocal realRequire = require\nrequire = function(name) return print(\"require '\" .. name.. \"': deprecated, use getPlugin()\") end \nlocal plugins = {}\nlocal pluginCache = {}\nfunction plugins:fixName(name)\n    local pp = packagePrefix\n    if string.find(name, pp) then\n        name = string.gsub(name, pp, \"\")\n    end\n\treturn name\nend\n\nfunction plugins:unloadPlugin(name,noPrefix,key)\n\tassert(type(name) == \"string\", \"getPlugin: parameter name has to be string, was \" .. type(name))\n\tname = plugins:fixName(name)\n    local pp = packagePrefix\n    if type(pluginCache[name]) == \"table\" and pluginCache[name].valid ~= nil then\n        if pluginCache[name]:valid(key) ~= true then\n            return nil\n        end\n    end\n\tif noPrefix then pp = \"\" end\n\tif package.loaded ~= nil and package.loaded[pp..name] ~= nil then\n\t\tpackage.loaded[pp..name] = nil\n\tend\n\tif pluginCache[name] ~= nil then\n\t\tif type(pluginCache[name]) == \"table\" and type(pluginCache[name].unregister) == \"function\" then\n\t\t\tpluginCache[name].unregister()\n\t\tend\n\t\tpluginCache[name] = nil\n\tend\nend\n-- optional key, will checked on function \"valid\" before returning plugin if it exist, otherwise defaults to return plugin\nfunction plugins:getPlugin(name,noError,key,noPrefix)\n    assert(type(name) == \"string\", \"getPlugin: parameter name has to be string, was \" .. type(name))\n    if noError == nil then noError = false end\n\tname = plugins:fixName(name)\n\t\n    if not plugins:hasPlugin(name,noError,noPrefix) then return nil end\n\n    if type(pluginCache[name]) == \"table\" and pluginCache[name].valid ~= nil then\n        if pluginCache[name]:valid(key) ~= true then\n            if not noError then print(\"getPlugin '\"..name..\"':\"..\" Not valid or compatible\") end\n            return nil\n        end\n    end\n\n    return pluginCache[name]\nend\nfunction plugins:hasPlugin(name,noError,noPrefix)\n    assert(type(name) == \"string\", \"hasPlugin: parameter name has to be string, was \" .. type(name))\n    if noError == nil then noError = false end\n    name = plugins:fixName(name)\n    local pp = packagePrefix\n\tif noPrefix then pp = \"\" end\n\t\n    if pluginCache[name] == nil then\n\t\tpluginCache[name] = false\n\n\t\tif (player.hasDRMAutorization() == 1  or package.preload[pp..name] ~= nil) or noPrefix then\n            local ok, res = pcall(realRequire, pp..name)\n\t\t\tif not ok then\n\t\t\t\tif noError == nil or not noError then\n\t\t\t\t\tsystem.print(\"hasPlugin '\"..name..\"': require failed\",res)\n\t\t\t\tend\n\t\t\telse\n\t\t\t\tpluginCache[name] = res\n\t\t\tend\n\t\telse\n\t\t\tprint(\"hasPlugin '\"..name..\"': DRM auth required to load external files\")\n\t\tend\n\n        if type(pluginCache[name]) == \"table\" then\n            if pluginCache[name].register ~= nil then\n                if _ENV[\"debugscreen\"] == nil then _ENV[\"debugscreen\"] = debugscreen end\n                if _ENV[\"register\"] == nil then _ENV[\"register\"] = register end\n                if _ENV[\"system\"] == nil then _ENV[\"system\"] = system end\n                if _ENV[\"unit\"] == nil then _ENV[\"unit\"] = unit end\n\t\t\t\tif _ENV[\"player\"] == nil then _ENV[\"player\"] = player end\n                if _ENV[\"construct\"] == nil then _ENV[\"construct\"] = construct end\n                if _ENV[\"library\"] == nil then _ENV[\"library\"] = library end\n                local ok2, res2 = pcall(pluginCache[name].register,pluginCache[name],_ENV)\n                if not ok2 and not noError then\n                    system.print(\"hasPlugin '\"..name..\"': register failed\",res2)\n                end\n            end\n        else\n            if pluginCache[name] ~= nil and pluginCache[name] ~= false then\n\t\t\t\tif type(pluginCache[name]) == \"string\" then \n\t\t\t\t\tprint(\"hasPlugin '\"..name..\"':\"..pluginCache[name])\n\t\t\t\telse\n\t\t\t\t\tprint(\"hasPlugin '\"..name..\"': not table value\")\n\t\t\t\tend\n                \n            end\n        end\n    end\n    return type(pluginCache[name]) == \"table\"\nend\nfunction unloadPlugin(name,noPrefix) return plugins:unloadPlugin(name,noPrefix) end\nfunction hasPlugin(name,noError,noPrefix) return plugins:hasPlugin(name,noError,noPrefix) end\nfunction getPlugin(name,noError,key,noPrefix) return plugins:getPlugin(name,noError,key,noPrefix) end\nlocal errorStack = {}\n\n-- NEEDS to be the FIRST initialized module! Register is the only implicit dependency\nunitType = \"\"  --export: Set behaviour type of element\nrenderEveryXFrames = 3 --export: Reduces the framerate of the interface.<br>Higher values will save more performance\nexecuteTotal = 0\nexecuteSet = 0\nexecuteTime = 0\nexecuteLastFrames = 0\nscreenToggle = true\nmode = -1\nforceMode = -1\n\nbootTime = system.getArkTime()\n\nuseLightStyle = false --export: Light style reduces the interface to digital numbers and indicators\n\nlocal mode1Color = 120 --export: Base color of interface<br>Range: 0-360<br>Try 120, 184 or 334. Can be any other number in range.\nlocal mode2Color = 184 --export: Space color of interface<br>Range: 0-360<br>Try 120, 184 or 334. Can be any other number in range.\n\nmodeColors = {}\nmodeColors[0] = mode1Color\nmodeColors[1] = mode2Color\n\nfuelTankHandlingSpace = 5 --export:\nfuelTankHandlingRocket = 0 --export:\nfuelTankHandlingAtmos = 0 --export:\nContainerOptimization = 5 --export:\nFuelTankOptimization = 5 --export:\n\nfunction collect_keys(t, sort)\n    local _k = {}\n    for k in pairs(t) do\n        _k[#_k+1] = k\n    end\n    table.sort(_k, sort)\n    return _k\nend\nfunction sortedPairs(t, sort)\n    local keys = collect_keys(t, sort)\n    local i = 0\n    return function()\n        i = i+1\n        if keys[i] then\n            return keys[i], t[keys[i]]\n        end\n    end\nend\nfunction tableLength(T)\n    local count = 0\n    for _ in pairs(T) do count = count + 1 end\n    return count\nend\n-- END orderedPairs functions\n\nfunction timeit(title, f)\n    collectgarbage()\n    local startTime = system.getTime()\n    local result = f()\n    local endTime = system.getTime()\n    print( title .. \": \" .. (endTime - startTime) )\n    return result\nend\nfunction getRelativePitch(velocity)\n    return math.deg(math.atan(velocity[2], velocity[3])) - 90\nend\nfunction getRelativeYaw(velocity)\n    return math.deg(math.atan(velocity[2], velocity[1])) - 90\nend\nfunction mysplit(inputstr, sep)\n    if sep == nil then sep = \"%s\" end\n    local t={}\n    for str in string.gmatch(inputstr, \"([^\"..sep..\"]+)\") do\n        table.insert(t, str)\n    end\n    return t\nend\nfunction inTable(tab, val)\n    if type(tab) ~= \"table\" then return false end\n    for k,v in pairs(tab) do\n        if v == val then return true,k end\n    end\n    return false\nend\nfunction round(num, numDecimalPlaces)\n    local mult = 10 ^ (numDecimalPlaces or 0)\n    if numDecimalPlaces ~= nil then\n        return math.floor(num * mult + 0.5) / mult\n    else\n        return math.floor((num * mult + 0.5) / mult)\n    end\nend\nif not inTable(player.getOrgIds(),2041) then system.print(\"Corp signatur required\") error(\"Corp signatur required\") u.exit() end\n\nregister = getPlugin(\"register\")\nslots = getPlugin(\"slots\")\n-- Simulate system start\nregister:callAction(\"systemStart\")\n\n--easier time with timers\nlocal Timer = {}\nfunction addTimer(ID, time, callback)\n    u.setTimer(ID, time)\n    Timer[ID] = callback\nend\n\nfunction onTimer(timerId)\n    if Timer[timerId] ~= nil then\n        local a,b = pcall(Timer[timerId])\n        if not a then print(\"Timer:\" .. b .. \"  \" .. timerId) end\n    end\nend\n\nfunction stopTimer()\n    for k,_ in pairs(Timer) do\n        u.setTimer(k,0)\n    end\nend\nlocal DelayCounter = 0\nfunction delay(func, time)\n    local ID = \"DelayCounter\".. DelayCounter\n    addTimer(ID, time, function() pcall(func) u.stopTimer(ID) end)\n    DelayCounter = DelayCounter + 1\nend\nregister:addAction(\"unitOnTimer\", \"Timer\", onTimer) \n\n-- Load all registrations from all packages. Will be late init\nif devMode == true then\n\tgetPlugin(\"dev\", true)\n\tgetPlugin(\"devTools\", true)\nend\ngetPlugin(\"optionals\", true)\n\nfor name,_ in sortedPairs(package.preload) do\n\tgetPlugin(name,true)\nend\n\ndelay(function() register:callAction(\"unitOnStart\") system.setScreen(\"\") end, 0.5)\n"},{"key":"6","filter":{"slotKey":-1,"signature":"onStop()","args":[]},"code":"if register ~= nil then register:callAction(\"unitOnStop\",unit) end"},{"key":"7","filter":{"slotKey":-1,"signature":"onTimer(tag)","args":[{"variable":"*"}]},"code":"if register ~= nil then register:callAction(\"unitOnTimer\",tag,unit) end"},{"key":"8","filter":{"slotKey":-2,"signature":"onActionStart(action)","args":[{"variable":"*"}]},"code":"if register ~= nil then register:callAction(\"systemOnActionStart\",action,system) end"},{"key":"9","filter":{"slotKey":-2,"signature":"onActionStop(action)","args":[{"variable":"*"}]},"code":"if register ~= nil then register:callAction(\"systemOnActionStop\",action,system) end"},{"key":"10","filter":{"slotKey":-2,"signature":"onActionLoop(action)","args":[{"variable":"*"}]},"code":"if register ~= nil then register:callAction(\"systemOnActionLoop\",action,system) end"},{"key":"11","filter":{"slotKey":-2,"signature":"onUpdate()","args":[]},"code":"if register ~= nil then register:callAction(\"systemOnUpdate\",system) end"},{"key":"12","filter":{"slotKey":-2,"signature":"onFlush()","args":[]},"code":"if register ~= nil then register:callAction(\"systemOnFlush\",system) end"},{"key":"13","filter":{"slotKey":-2,"signature":"onInputText(text)","args":[{"variable":"*"}]},"code":"if register ~= nil then register:callAction(\"systemOnInputText\",text,system) end"},{"key":"14","filter":{"slotKey":-2,"signature":"onCameraChanged(mode)","args":[{"variable":"*"}]},"code":"if register ~= nil then register:callAction(\"systemOnCameraChanged\",mode,system) end"},{"key":"15","filter":{"slotKey":-4,"signature":"onParentChanged(oldId,newId)","args":[{"variable":"*"},{"variable":"*"}]},"code":"if register ~= nil then register:callAction(\"playerOnParentChanged\",oldId,newId,player) end"},{"key":"16","filter":{"slotKey":-5,"signature":"onDocked(id)","args":[{"variable":"*"}]},"code":"if register ~= nil then register:callAction(\"constructOnDocked\",id,construct) end"},{"key":"17","filter":{"slotKey":-5,"signature":"onUndocked(id)","args":[{"variable":"*"}]},"code":"if register ~= nil then register:callAction(\"constructOnUndocked\",id,construct) end"},{"key":"18","filter":{"slotKey":-5,"signature":"onPlayerBoarded(id)","args":[{"variable":"*"}]},"code":"if register ~= nil then register:callAction(\"constructOnPlayerBoarded\",id,construct) end"},{"key":"19","filter":{"slotKey":-5,"signature":"onVRStationEntered(id)","args":[{"variable":"*"}]},"code":"if register ~= nil then register:callAction(\"constructOnVRStationEntered\",id,construct) end"},{"key":"20","filter":{"slotKey":-5,"signature":"onConstructDocked(id)","args":[{"variable":"*"}]},"code":"if register ~= nil then register:callAction(\"constructOnConstructDocked\",id,construct) end"},{"key":"21","filter":{"slotKey":-5,"signature":"onPvPTimer(active)","args":[{"variable":"*"}]},"code":"if register ~= nil then register:callAction(\"constructOnPvPTimer\",active,construct) end"}],"methods":[],"events":[]}